<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Heart Scroll Fixed Mobile</title>
    <style>
        body, html { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            background-color: #050510; 
            /* Quan tr·ªçng: Ch·∫∑n h√†nh vi cu·ªôn/zoom m·∫∑c ƒë·ªãnh c·ªßa tr√¨nh duy·ªát tr√™n mobile */
            touch-action: none; 
        }
        canvas { display: block; }
    </style>
</head>
<body>

<canvas id="mainCanvas"></canvas>

<script>
// Ki·ªÉm tra thi·∫øt b·ªã mobile
const isMobile = window.innerWidth < 768;

const CONFIG = {
    messages: ["B√â LINH Y√äU", "CH√öC EM ", "VALENTINE","VUI V·∫∫ NH√â",  "ANH Y√äU EM"],
    // Mobile c·∫ßn m·∫≠t ƒë·ªô th∆∞a h∆°n ch√∫t ƒë·ªÉ ƒë·ª° lag, nh∆∞ng step nh·ªè h∆°n ƒë·ªÉ ch·ªØ m·ªãn h∆°n tr√™n m√†n nh·ªè
    particleStep: isMobile ? 6 : 8, 
    heartColor: "#ff4d6d",
    glowColor: "#ff758f",
    scrollDelay: 4000, 
    spawnRate: isMobile ? 2 : 4, // Gi·∫£m t·ªëc ƒë·ªô b·∫Øn tr√™n mobile ƒë·ªÉ ti·∫øt ki·ªám pin
};

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
let width, height;
let particles = [];
let stars = [];
let shootingStars = [];
let currentMsgIndex = -1;
let cameraY = 0;
let targetCameraY = 0;
let isAutoScrolling = true;

// Bi·∫øn h·ªó tr·ª£ touch scroll
let touchStartY = 0;
let lastTouchY = 0;
let isDragging = false;

const tCanvas = document.createElement('canvas');
const tCtx = tCanvas.getContext('2d');

class Star {
    constructor() { this.reset(); }
    reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.size = Math.random() * (isMobile ? 1.2 : 1.5);
        this.angle = Math.random() * Math.PI * 2;
        this.blinkSpeed = 0.02 + Math.random() * 0.03;
    }
    draw() {
        this.angle += this.blinkSpeed;
        const opacity = 0.1 + Math.abs(Math.sin(this.angle)) * 0.8;
        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

class ShootingStar {
    constructor() { this.init(); }
    init() {
        this.x = Math.random() * width;
        this.y = Math.random() * (height / 2);
        this.len = Math.random() * 80 + 30;
        this.speed = Math.random() * 10 + 7;
        this.active = false;
        this.opacity = 0;
    }
    update() {
        if (!this.active) { if (Math.random() < 0.005) this.active = true; return; }
        this.x += this.speed; this.y += this.speed * 0.5;
        this.opacity = Math.min(1, this.opacity + 0.05);
        if (this.x > width || this.y > height) this.init();
    }
    draw() {
        if (!this.active) return;
        ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - this.len, this.y - (this.len * 0.5));
        ctx.stroke();
    }
}

class HeartParticle {
    constructor(tx, ty) {
        // V·ªã tr√≠ b·∫Øn ra t·ª´ G·∫•u (Canh gi·ªØa b√™n d∆∞·ªõi cho mobile d·ªÖ nh√¨n h∆°n)
        this.x = 40; 
        this.y = height + cameraY - 40; 
        
        this.vx = (Math.random() * 20) + 5; 
        this.vy = (Math.random() * -25) - 15;
        this.targetX = tx;
        this.targetY = ty;
        
        // Mobile h·∫°t to h∆°n x√≠u cho d·ªÖ th·∫•y
        this.size = Math.random() * 2 + (isMobile ? 1.5 : 1.2);
        this.speed = Math.random() * 0.04 + 0.02; 
        this.friction = 0.92;
        this.active = false;
    }
    update() {
        if (!this.active) return;

        let dx = this.targetX - this.x;
        let dy = this.targetY - this.y;
        this.vx += dx * this.speed;
        this.vy += dy * this.speed;
        this.vx *= this.friction;
        this.vy *= this.friction;
        this.x += this.vx;
        this.y += this.vy;

        // T∆∞∆°ng t√°c chu·ªôt / c·∫£m ·ª©ng
        let worldMouseX = mouse.x;
        let worldMouseY = mouse.y + cameraY;
        let mdx = worldMouseX - this.x;
        let mdy = worldMouseY - this.y;
        let dist = Math.sqrt(mdx * mdx + mdy * mdy);
        
        // TƒÉng v√πng ·∫£nh h∆∞·ªüng tr√™n mobile v√¨ ng√≥n tay to h∆°n con tr·ªè
        let interactRadius = isMobile ? 100 : 80; 

        if (dist < interactRadius) {
            let angle = Math.atan2(mdy, mdx);
            let force = (interactRadius - dist) / interactRadius;
            this.x -= Math.cos(angle) * force * 20;
            this.y -= Math.sin(angle) * force * 20;
        }
    }
    draw() {
        if (!this.active) return;
        const displayY = this.y - cameraY;
        // T·ªëi ∆∞u: Kh√¥ng v·∫Ω h·∫°t ngo√†i m√†n h√¨nh
        if (displayY < -50 || displayY > height + 50) return;

        ctx.fillStyle = CONFIG.heartColor;
        ctx.shadowBlur = isMobile ? 4 : 8; // Gi·∫£m shadow tr√™n mobile ƒë·ªÉ m∆∞·ª£t
        ctx.shadowColor = CONFIG.glowColor;
        const x = this.x, y = displayY, s = this.size;
        
        // V·∫Ω h√¨nh tim ƒë∆°n gi·∫£n h∆°n ch√∫t n·∫øu l√† mobile y·∫øu, ho·∫∑c gi·ªØ nguy√™n
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.bezierCurveTo(x, y - s*1.5, x - s*2, y - s*1.5, x - s*2, y);
        ctx.bezierCurveTo(x - s*2, y + s*1.5, x, y + s*2.5, x, y + s*3.5);
        ctx.bezierCurveTo(x, y + s*2.5, x + s*2, y + s*1.5, x + s*2, y);
        ctx.bezierCurveTo(x + s*2, y - s*1.5, x, y - s*1.5, x, y);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

let particleCursor = 0;

function nextMessage() {
    if (currentMsgIndex >= CONFIG.messages.length - 1) return;
    
    currentMsgIndex++;
    const text = CONFIG.messages[currentMsgIndex];
    tCanvas.width = width;
    tCanvas.height = height;
    
    // T√çNH TO√ÅN FONT CH·ªÆ TH√îNG MINH H∆†N CHO MOBILE
    // Mobile m√†n d·ªçc (width nh·ªè) c·∫ßn chia t·ª∑ l·ªá kh√°c Desktop
    let fontSizeFactor = isMobile ? 0.6 : 0.8; 
    let maxFont = isMobile ? 80 : 120;
    let dynamicFontSize = Math.min(width / (text.length * fontSizeFactor), maxFont);

    tCtx.fillStyle = "white";
    tCtx.font = `bold ${dynamicFontSize}px Arial`;
    tCtx.textAlign = "center";
    tCtx.textBaseline = "middle";
    tCtx.fillText(text, width / 2, height / 2);

    const data = tCtx.getImageData(0, 0, width, height).data;
    const offsetY = currentMsgIndex * height;
    
    if (isAutoScrolling) targetCameraY = offsetY;

    for (let y = 0; y < height; y += CONFIG.particleStep) {
        for (let x = 0; x < width; x += CONFIG.particleStep) {
            if (data[(y * width + x) * 4 + 3] > 128) {
                particles.push(new HeartParticle(x, y + offsetY));
            }
        }
    }
}

function animate() {
    const g = ctx.createLinearGradient(0, 0, 0, height);
    g.addColorStop(0, "#050510");
    g.addColorStop(1, "#1a0a2e");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, width, height);

    stars.forEach(s => s.draw());
    shootingStars.forEach(ss => { ss.update(); ss.draw(); });

    // Hi·ªáu ·ª©ng easing cho scroll
    cameraY += (targetCameraY - cameraY) * 0.1;

    for (let i = 0; i < CONFIG.spawnRate; i++) {
        if (particleCursor < particles.length) {
            let p = particles[particleCursor];
            p.active = true;
            // C·∫≠p nh·∫≠t v·ªã tr√≠ xu·∫•t ph√°t theo cameraY hi·ªán t·∫°i
            p.y = height + cameraY - 40; 
            particleCursor++;
        }
    }

    ctx.font = "40px Arial";
    ctx.textAlign = "left"; // ƒê·ªÉ icon g·∫•u ·ªü g√≥c tr√°i
    ctx.fillStyle = "white";
    ctx.fillText("üêª", 20, height - 20);

    particles.forEach(p => { p.update(); p.draw(); });

    requestAnimationFrame(animate);
}

// --- X·ª¨ L√ù S·ª∞ KI·ªÜN CHU·ªòT & C·∫¢M ·ª®NG (QUAN TR·ªåNG) ---

let mouse = { x: -1000, y: -1000 };

// 1. Mouse Move & Touch Move (Hi·ªáu ·ª©ng h·∫°t n√© ra)
function updatePointer(x, y) {
    mouse.x = x;
    mouse.y = y;
}

window.addEventListener('mousemove', e => updatePointer(e.clientX, e.clientY));
window.addEventListener('touchmove', e => {
    e.preventDefault(); // Ch·∫∑n k√©o trang web
    updatePointer(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });

// 2. Scroll logic (K·∫øt h·ª£p Wheel v√† Touch Drag)

// Desktop Wheel
window.addEventListener('wheel', e => {
    isAutoScrolling = false; 
    targetCameraY += e.deltaY;
    clampScroll();
}, { passive: false });

// Mobile Touch Drag
window.addEventListener('touchstart', e => {
    isAutoScrolling = false;
    touchStartY = e.touches[0].clientY;
    lastTouchY = targetCameraY;
    isDragging = true;
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ chu·ªôt ngay khi ch·∫°m ƒë·ªÉ hi·ªáu ·ª©ng h·∫°t ho·∫°t ƒë·ªông ngay
    updatePointer(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });

window.addEventListener('touchmove', e => {
    if (!isDragging) return;
    const currentTouchY = e.touches[0].clientY;
    const deltaY = touchStartY - currentTouchY; // K√©o l√™n th√¨ scroll xu·ªëng
    
    targetCameraY += deltaY * 1.5; // *1.5 ƒë·ªÉ c·∫£m gi√°c vu·ªët nhanh h∆°n
    touchStartY = currentTouchY; // Reset cho frame ti·∫øp theo
    clampScroll();
}, { passive: false });

window.addEventListener('touchend', () => {
    isDragging = false;
    mouse.x = -1000; // B·ªè ng√≥n tay ra th√¨ reset v·ªã tr√≠ t∆∞∆°ng t√°c
});

function clampScroll() {
    const maxScroll = (CONFIG.messages.length - 1) * height;
    if (targetCameraY < 0) targetCameraY = 0;
    if (targetCameraY > maxScroll) targetCameraY = maxScroll;
}

// Resize logic
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    stars = [];
    for (let i = 0; i < (isMobile ? 80 : 150); i++) stars.push(new Star());
    shootingStars = [new ShootingStar()];
    
    // N·∫øu resize, reset l·∫°i logic ch·ªØ ƒë·ªÉ t√≠nh l·∫°i font
    particles = [];
    particleCursor = 0;
    currentMsgIndex = -1;
    nextMessage();
}

window.addEventListener('resize', resize);
resize();
animate();

setInterval(() => {
    if (isAutoScrolling && currentMsgIndex < CONFIG.messages.length - 1) {
        nextMessage();
    } else if (!isAutoScrolling && currentMsgIndex < CONFIG.messages.length - 1) {
        // V·∫´n load ch·ªØ ti·∫øp theo ng·∫ßm ƒë·ªãnh d√π ƒëang scroll tay
        // check kho·∫£ng c√°ch scroll ƒë·ªÉ load ti·∫øp
        const maxScroll = (CONFIG.messages.length - 1) * height;
        if (targetCameraY > maxScroll - height / 2) {
             nextMessage();
        }
    }
}, CONFIG.scrollDelay);

</script>
</body>
</html>