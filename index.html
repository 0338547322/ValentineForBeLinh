<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heart Scroll Fixed</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #050510; }
        canvas { display: block; cursor: ns-resize; }
    </style>
</head>
<body>

<canvas id="mainCanvas"></canvas>

<script>
const CONFIG = {
    messages: ["BÃ‰ LINH YÃŠU Dáº¤U", "CHÃšC EM VALENTINE VUI Váºº NHÃ‰",  "ANH YÃŠU EM"],
    particleStep: 10, // TÄƒng nháº¹ Ä‘á»ƒ mÆ°á»£t hÆ¡n
    heartColor: "#ff4d6d",
    glowColor: "#ff758f",
    scrollDelay: 5000, 
    spawnRate: 3, // TÄƒng tá»‘c Ä‘á»™ báº¯n Ä‘á»ƒ chá»¯ hiá»‡n nhanh hÆ¡n
};

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
let width, height;
let particles = [];
let stars = [];
let shootingStars = [];
let currentMsgIndex = -1;
let cameraY = 0;
let targetCameraY = 0;
let isAutoScrolling = true;

const tCanvas = document.createElement('canvas');
const tCtx = tCanvas.getContext('2d');

class Star {
    constructor() { this.reset(); }
    reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.size = Math.random() * 1.5;
        this.angle = Math.random() * Math.PI * 2;
        this.blinkSpeed = 0.02 + Math.random() * 0.03;
    }
    draw() {
        this.angle += this.blinkSpeed;
        const opacity = 0.1 + Math.abs(Math.sin(this.angle)) * 0.8;
        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

class ShootingStar {
    constructor() { this.init(); }
    init() {
        this.x = Math.random() * width;
        this.y = Math.random() * (height / 2);
        this.len = Math.random() * 80 + 30;
        this.speed = Math.random() * 10 + 7;
        this.active = false;
        this.opacity = 0;
    }
    update() {
        if (!this.active) { if (Math.random() < 0.005) this.active = true; return; }
        this.x += this.speed; this.y += this.speed * 0.5;
        this.opacity = Math.min(1, this.opacity + 0.05);
        if (this.x > width || this.y > height) this.init();
    }
    draw() {
        if (!this.active) return;
        ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - this.len, this.y - (this.len * 0.5));
        ctx.stroke();
    }
}

class HeartParticle {
    constructor(tx, ty) {
        // LUÃ”N báº¯n ra tá»« vá»‹ trÃ­ Gáº¥u trÃªn mÃ n hÃ¬nh hiá»‡n táº¡i
        this.x = 40; 
        this.y = height + cameraY - 20; 
        this.vx = (Math.random() * 20) + 5; 
        this.vy = (Math.random() * -25) - 15;
        this.targetX = tx;
        this.targetY = ty;
        this.size = Math.random() * 2 + 1.2;
        this.speed = Math.random() * 0.03 + 0.02; 
        this.friction = 0.92;
        this.active = false;
    }
    update() {
        if (!this.active) return;

        let dx = this.targetX - this.x;
        let dy = this.targetY - this.y;
        this.vx += dx * this.speed;
        this.vy += dy * this.speed;
        this.vx *= this.friction;
        this.vy *= this.friction;
        this.x += this.vx;
        this.y += this.vy;

        let worldMouseX = mouse.x;
        let worldMouseY = mouse.y + cameraY;
        let mdx = worldMouseX - this.x;
        let mdy = worldMouseY - this.y;
        let dist = Math.sqrt(mdx * mdx + mdy * mdy);
        if (dist < 80) {
            let angle = Math.atan2(mdy, mdx);
            let force = (80 - dist) / 80;
            this.x -= Math.cos(angle) * force * 20;
            this.y -= Math.sin(angle) * force * 20;
        }
    }
    draw() {
        if (!this.active) return;
        const displayY = this.y - cameraY;
        if (displayY < -100 || displayY > height + 100) return;

        ctx.fillStyle = CONFIG.heartColor;
        ctx.shadowBlur = 8;
        ctx.shadowColor = CONFIG.glowColor;
        const x = this.x, y = displayY, s = this.size;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.bezierCurveTo(x, y - s*1.5, x - s*2, y - s*1.5, x - s*2, y);
        ctx.bezierCurveTo(x - s*2, y + s*1.5, x, y + s*2.5, x, y + s*3.5);
        ctx.bezierCurveTo(x, y + s*2.5, x + s*2, y + s*1.5, x + s*2, y);
        ctx.bezierCurveTo(x + s*2, y - s*1.5, x, y - s*1.5, x, y);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

let particleCursor = 0;

function nextMessage() {
    if (currentMsgIndex >= CONFIG.messages.length - 1) return;
    
    currentMsgIndex++;
    const text = CONFIG.messages[currentMsgIndex];
    tCanvas.width = width;
    tCanvas.height = height;
    let dynamicFontSize = Math.min(width / (text.length * 0.8), 120);
    tCtx.fillStyle = "white";
    tCtx.font = `bold ${dynamicFontSize}px Arial`;
    tCtx.textAlign = "center";
    tCtx.textBaseline = "middle";
    tCtx.fillText(text, width / 2, height / 2);

    const data = tCtx.getImageData(0, 0, width, height).data;
    const offsetY = currentMsgIndex * height;
    
    if (isAutoScrolling) targetCameraY = offsetY;

    for (let y = 0; y < height; y += CONFIG.particleStep) {
        for (let x = 0; x < width; x += CONFIG.particleStep) {
            if (data[(y * width + x) * 4 + 3] > 128) {
                particles.push(new HeartParticle(x, y + offsetY));
            }
        }
    }
}

function animate() {
    const g = ctx.createLinearGradient(0, 0, 0, height);
    g.addColorStop(0, "#050510");
    g.addColorStop(1, "#1a0a2e");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, width, height);

    stars.forEach(s => s.draw());
    shootingStars.forEach(ss => { ss.update(); ss.draw(); });

    cameraY += (targetCameraY - cameraY) * 0.07;

    // QUAN TRá»ŒNG: Cáº­p nháº­t vá»‹ trÃ­ xuáº¥t phÃ¡t cá»§a háº¡t chÆ°a kÃ­ch hoáº¡t theo Camera
    // Ä‘á»ƒ trÃ¡nh viá»‡c báº¯n lá»‡ch khi Ä‘ang scroll
    for (let i = 0; i < CONFIG.spawnRate; i++) {
        if (particleCursor < particles.length) {
            let p = particles[particleCursor];
            p.active = true;
            // Cáº­p nháº­t láº¡i Ä‘iá»ƒm xuáº¥t phÃ¡t ngay lÃºc báº¯n Ä‘á»ƒ khá»›p vá»›i vá»‹ trÃ­ Gáº¥u hiá»‡n táº¡i
            p.y = height + cameraY - 20; 
            particleCursor++;
        }
    }

    ctx.font = "40px Arial";
    ctx.textAlign = "center";
    ctx.fillStyle = "white";
    ctx.fillText("ðŸ»", 40, height - 20);

    particles.forEach(p => { p.update(); p.draw(); });

    requestAnimationFrame(animate);
}

let mouse = { x: -1000, y: -1000 };
window.addEventListener('mousemove', e => { 
    mouse.x = e.clientX; 
    mouse.y = e.clientY; 
});

window.addEventListener('wheel', e => {
    isAutoScrolling = false; 
    targetCameraY += e.deltaY;
    const maxScroll = (CONFIG.messages.length - 1) * height;
    if (targetCameraY < 0) targetCameraY = 0;
    if (targetCameraY > maxScroll) targetCameraY = maxScroll;
});

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    stars = [];
    for (let i = 0; i < 150; i++) stars.push(new Star());
    shootingStars = [new ShootingStar(), new ShootingStar()];
    if (currentMsgIndex === -1) nextMessage();
}

window.addEventListener('resize', resize);
resize();
animate();

// Cáº£i tiáº¿n Interval Ä‘á»ƒ luÃ´n táº¡o chá»¯ má»›i dÃ¹ Ä‘ang scroll tay hay auto
setInterval(() => {
    if (currentMsgIndex < CONFIG.messages.length - 1) {
        nextMessage();
    }
}, CONFIG.scrollDelay);

</script>
</body>

</html>

